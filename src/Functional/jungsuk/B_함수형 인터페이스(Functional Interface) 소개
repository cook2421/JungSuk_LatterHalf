자바에서 모든 메소드는 클래스 내에 포함되어야 하는데, 람다식은 어떤 클래스에 포함되는 것일까?
이미 알고 있는 것처럼 참조변수가 있어야 객체의 메소드를 호출할 수 있으니까 일단 이 익명 객체의 주소를 f라는 참조변수에 저장해 보자.


타입 f = (int a, int b) -> a > b ? a : b;     // 참조변수의 타입을 뭘로 해야 할까?


참조형이니까 클래스 또는 인터페이스가 가능하다.
그리고 람다식과 동등한 메소드가 정의되어 있는 것이어야 한다.
그래야만 참조변수로 익명 객체(람다식)의 메소드를 호출할 수 있기 때문이다.


예를 들어 아래와 같이 max()라는 메소드가 정의된 MyFunction 인터페이스가 정의되어 있다고 가정하자.
interface MyFunction {
    public abstract int max(int a, int b);
}


그러면 이 인터페이스를 구현한 익명 클래스의 객체는 다음과 같이 생성할 수 있다.
MyFunction f = new MyFunction() {
                    public int max(int a, int b) {
                        return a > b ? a : b;
                    }
                };
int big = f.max(5, 3);      // 익명 객체의 메소드 호출


MyFunction 인터페이스에 정의된 메소드 max()는 람다식 '(int a, int b) -> a > b ? a : b'와 메소드의 선언부가 일치한다.
그래서 위 코드의 익명 객체를 람다식으로 아래와 같이 대체할 수 있다.
MyFunction f = (int a, int b) -> a > b ? a : b;     // 익명 객체를 람다식으로 대체
int big = f.max(5, 3);      // 익명 객체의 메소드를 호출


이처럼 MyFunction 인터페이스를 구현한 익명 객체를 람다식으로 대체가 가능한 이유는,
람다식도 실제로는 익명 객체이고, MyFunction 인터페이스를 구현한 익명 객체의 메소드 max()와 람다식의 매개변수의 타입과 개수 그리고 반환값이 일치하기 때문이다.


지금까지 살펴본 것처럼, 하나의 메소드가 선언된 인터페이스를 정의해서
인터페이스를 통해 람다식을 다루는 것은 기존의 자바의 규칙들을 어기지 않으면서도 자연스럽다.
그래서 인터페이스를 통해 람다식을 다루기로 결정되었으며, 람다식을 다루기 위한 인터페이스를 '함수형 인터페이스(functional interface)'라고 부르기로 했다.


@FunctionalInterface
interface MyFunction {      // 함수형 인터페이스 MyFunction을 정의
    public abstract int max(int a, int b);
}

('@FunctionalInterface'를 붙이면, 컴파일러가 함수형 인터페이스를 올바르게 정의하였는지 확인해주므로, 꼭 붙이도록 하자)
(함수형 인터페이스에는 오직 하나의 추상 메소드만 정의되어 있어야 한다는 제약이 있다.
 그래야 람다식과 인터페이스의 메소드가 1:1로 연결될 수 있기 때문이다.
 반면에 static 메소드와 default 메소드의 개수에는 제약이 없다)